binary_sensor:
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Charging Operation"
    address: 11
    register_type: holding
    bitmask: 0x0100

  #      Bit 9: Status: Discharging operation
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Discharging Operation"
    address: 11
    register_type: holding
    bitmask: 0x0200

  #      Bit 10: Status: Charging enabled/disabled
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Charging"
    address: 11
    register_type: holding
    bitmask: 0x0400

  #      Bit 11: Status: Discharging enabled/disabled
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Discharging"
    address: 11
    register_type: holding
    bitmask: 0x0800

  #  12  Balance status-bits per cell (1-16)   2 byte   R  uint16  Hex
  #      Bit 1: Status: Balancing cell 1
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 1"
    address: 12
    register_type: holding
    bitmask: 0x0001

  #      Bit 2: Status: Balancing cell 2
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 2"
    address: 12
    register_type: holding
    bitmask: 0x0002

  #      Bit 3: Status: Balancing cell 3
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 3"
    address: 12
    register_type: holding
    bitmask: 0x0004

  #      Bit 4: Status: Balancing cell 4
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 4"
    address: 12
    register_type: holding
    bitmask: 0x0008

  #      Bit 5: Status: Balancing cell 5
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 5"
    address: 12
    register_type: holding
    bitmask: 0x0010

  #      Bit 6: Status: Balancing cell 6
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 6"
    address: 12
    register_type: holding
    bitmask: 0x0020

  #      Bit 7: Status: Balancing cell 7
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 7"
    address: 12
    register_type: holding
    bitmask: 0x0040

  #      Bit 8: Status: Balancing cell 8
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 8"
    address: 12
    register_type: holding
    bitmask: 0x0080

  #      Bit 9: Status: Balancing cell 9
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 9"
    address: 12
    register_type: holding
    bitmask: 0x0100

  #      Bit 10: Status: Balancing cell 10
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 10"
    address: 12
    register_type: holding
    bitmask: 0x0200

  #      Bit 11: Status: Balancing cell 11
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 11"
    address: 12
    register_type: holding
    bitmask: 0x0400

  #      Bit 12: Status: Balancing cell 12
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 12"
    address: 12
    register_type: holding
    bitmask: 0x0800

  #      Bit 13: Status: Balancing cell 13
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 13"
    address: 12
    register_type: holding
    bitmask: 0x1000

  #      Bit 14: Status: Balancing cell 14
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 14"
    address: 12
    register_type: holding
    bitmask: 0x2000

  #      Bit 15: Status: Balancing cell 15
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 15"
    address: 12
    register_type: holding
    bitmask: 0x4000

  #      Bit 16: Status: Balancing cell 16
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Balancing 16"
    address: 12
    register_type: holding
    bitmask: 0x8000

sensor:
  # Current 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Current"
    address: 0
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Voltage
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Total Voltage"
    address: 1
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Power 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Power"
    address: 0
    register_type: holding
    value_type: U_WORD
    register_count: 2
    response_size: 4
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 2
    lambda: |-
      if (data.size() < 4) {
        return NAN;
      }
      float current = (int16_t)(data[0] << 8 | data[1] << 0);
      float total_voltage = (uint16_t)(data[2] << 8 | data[3] << 0);
      return current * total_voltage * 0.0001f;

  # State of Charge 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} State of Charge"
    address: 2
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0

  # State of Health 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} State of Health"
    address: 3
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 0

  # Remaining Capacity 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Remaining Capacity"
    address: 4
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Ah"
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Full Capacity 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Full Capacity"
    address: 5
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Ah"
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Design Capacity 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Design Capacity"
    address: 6
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Ah"
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  # Charging Cycles 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Charging Cycles"
    address: 7
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: ""
    state_class: measurement
    accuracy_decimals: 0

  # Warnings Bitmask 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Warnings Bitmask"
    address: 9
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: ""
    state_class: measurement
    accuracy_decimals: 0

  # Protections Bitmask 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Protections Bitmask"
    address: 10
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: ""
    state_class: measurement
    accuracy_decimals: 0

  # Fault Status Bitmask 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Fault Status Bitmask"
    address: 11
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: ""
    state_class: measurement
    accuracy_decimals: 0

  # Balancer Status 
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Balancer Status"
    address: 12
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: ""
    state_class: measurement
    accuracy_decimals: 0

  #  13  Reserved
  #  14  Reserved

  # Cell voltage 1
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 1"
    address: 15
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 2
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 2"
    address: 16
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 3
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 3"
    address: 17
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 4
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 4"
    address: 18
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 5
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 5"
    address: 19
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 6
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 6"
    address: 20
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 7
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 7"
    address: 21
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 8
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 8"
    address: 22
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 9
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 9"
    address: 23
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 10
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 10"
    address: 24
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 11
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 11"
    address: 25
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 12
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 12"
    address: 26
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 13
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 13"
    address: 27
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 14
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 14"
    address: 28
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 15
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 15"
    address: 29
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Cell voltage 16
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Voltage 16"
    address: 30
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  ### Calculated sensors

  # Delta cell voltage
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Delta Cell Voltage"
    address: 15
    register_type: holding
    value_type: U_WORD
    register_count: 16
    response_size: 32
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      uint8_t cells = 16;
      if (data.size() < cells * 2) {
        return NAN;
      }

      float min_cell_voltage = 100.0f;
      float max_cell_voltage = -100.0f;
      float average_cell_voltage = 0.0f;
      uint8_t min_voltage_cell = 0;
      uint8_t max_voltage_cell = 0;
      for (uint8_t i = 0; i < cells; i++) {
        float cell_voltage = (uint16_t)(data[item->offset + (i * 2)] << 8 | data[item->offset + (i * 2) + 1] << 0) * 0.001f;
        average_cell_voltage += cell_voltage;
        if (cell_voltage < min_cell_voltage) {
            min_cell_voltage = cell_voltage;
            min_voltage_cell = i + 1;
        }
        if (cell_voltage > max_cell_voltage) {
          max_cell_voltage = cell_voltage;
          max_voltage_cell = i + 1;
        }
      }
      average_cell_voltage /= cells;

      id(${modbus_controller_id}_average_cell_voltage).publish_state(average_cell_voltage);
      id(${modbus_controller_id}_min_cell_voltage).publish_state(min_cell_voltage);
      id(${modbus_controller_id}_max_cell_voltage).publish_state(max_cell_voltage);
      id(${modbus_controller_id}_min_voltage_cell).publish_state(min_voltage_cell);
      id(${modbus_controller_id}_max_voltage_cell).publish_state(max_voltage_cell);

      return max_cell_voltage - min_cell_voltage;

  # Template sensor for average cell voltage
  - platform: template
    id: ${modbus_controller_id}_average_cell_voltage
    name: "${friendly_name} ${pack} Average Cell Voltage"
    update_interval: never
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3

  # Template sensor for min cell voltage
  - platform: template
    id: ${modbus_controller_id}_min_cell_voltage
    name: "${friendly_name} ${pack} Min Cell Voltage"
    update_interval: never
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3

  # Template sensor for max cell voltage
  - platform: template
    id: ${modbus_controller_id}_max_cell_voltage
    name: "${friendly_name} ${pack} Max Cell Voltage"
    update_interval: never
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3

  # Template sensor for min voltage cell index
  - platform: template
    id: ${modbus_controller_id}_min_voltage_cell
    name: "${friendly_name} ${pack} Min Voltage Cell"
    update_interval: never
    unit_of_measurement: ""
    state_class: measurement
    accuracy_decimals: 0

  # Template sensor for max voltage cell index
  - platform: template
    id: ${modbus_controller_id}_max_voltage_cell
    name: "${friendly_name} ${pack} Max Voltage Cell"
    update_interval: never
    unit_of_measurement: ""
    state_class: measurement
    accuracy_decimals: 0

  ####

  ### Temperatures for 

  # 31  Battery temperature 1 (0.1 ℃ resolution)
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Battery Temperature 1"
    address: 31
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  # 32  Battery temperature 2 (0.1 ℃ resolution)
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Battery Temperature 2"
    address: 32
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  # 33  Battery temperature 3 (0.1 ℃ resolution)
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Battery Temperature 3"
    address: 33
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  # 34  Battery temperature 4 (0.1 ℃ resolution)
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Battery Temperature 4"
    address: 34
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  # 35  MOSFET temperature (0.1 ℃ or invalid)
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} MOSFET Temperature"
    address: 35
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  # 36  Environment temperature (0.1 ℃ or invalid)
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Environment Temperature"
    address: 36
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  #  37-59  Reserved

number:

  #  60   OV alarm                         2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Overvoltage Alarm"
    use_write_multiple: true
    address: 60
    register_type: holding
    value_type: U_WORD
    min_value: 0.0 
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  61   OV protection                    2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Overvoltage Protection"
    use_write_multiple: true
    address: 61
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  62   OV release protection            2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Overvoltage Protection Release"
    use_write_multiple: true
    address: 62
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  63   OV protection delay time         2 byte  RW  uint8   0.1S 1~255
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Overvoltage Protection Delay Time"
    use_write_multiple: true
    address: 63
    register_type: holding
    value_type: U_WORD
    lambda: "return  x * 0.1f; "
    write_lambda: "return x * 10.0f;"
    min_value: 0.1
    max_value: 25.5
    step: 0.1
    mode: box
    unit_of_measurement: "s"

  #  64  Cell OV alarm                         2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Overvoltage Alarm"
    use_write_multiple: true
    address: 64
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  65  Cell OV protection                    2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Overvoltage Protection"
    use_write_multiple: true
    address: 65
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  66  Cell OV release protection            2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Overvoltage Protection Release"
    use_write_multiple: true
    address: 66
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  67  Cell OV protection delay time         2 byte  RW   uint8  0.1S 1~255
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Overvoltage Protection Delay Time"
    use_write_multiple: true
    address: 67
    register_type: holding
    value_type: U_WORD
    lambda: "return  x * 0.1f; "
    write_lambda: "return x * 10.0f;"
    min_value: 0.1
    max_value: 25.5
    step: 0.1
    mode: box
    unit_of_measurement: "s"

  #  68   UV alarm                         2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Undervoltage Alarm"
    use_write_multiple: true
    address: 68
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  69   UV protection                    2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Undervoltage Protection"
    use_write_multiple: true
    address: 69
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  73  Cell UV Protection                    2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Undervoltage Protection"
    use_write_multiple: true
    address: 73
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  74  Cell UV Release Protection            2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Undervoltage Protection Release"
    use_write_multiple: true
    address: 74
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  75  Cell UV Protection Delay Time         2 byte  RW   uint8  0.1S 1~255
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Undervoltage Protection Delay Time"
    use_write_multiple: true
    address: 75
    register_type: holding
    value_type: U_WORD
    lambda: "return  x * 0.1f; "
    write_lambda: "return x * 10.0f;"
    min_value: 0.1
    max_value: 25.5
    step: 0.1
    mode: box
    unit_of_measurement: "s"

  #  76  Charging OC Alarm                     2 byte  RW  uint16  A
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Charging Overcurrent Alarm"
    use_write_multiple: true
    address: 76
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "A"

  #  77  Charging OC Protection                2 byte  RW  uint16  A
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Charging Overcurrent Protection"
    use_write_multiple: true
    address: 77
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "A"

  #  78  Charging OC Protection Delay Time     2 byte  RW   uint8  0.1S 1~255
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Charging Overcurrent Protection Delay Time"
    use_write_multiple: true
    address: 78
    register_type: holding
    value_type: U_WORD
    lambda: "return  x * 0.1f; "
    write_lambda: "return x * 10.0f;"
    min_value: 0.1
    max_value: 25.5
    step: 0.1
    mode: box
    unit_of_measurement: "s"

  #  79  Discharging OC Alarm                  2 byte  RW  uint16  A
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Discharging Overcurrent Alarm"
    use_write_multiple: true
    address: 79
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "A"

  #  80  Discharging OC Protection             2 byte  RW  uint16  A
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Discharging Overcurrent Protection"
    use_write_multiple: true
    address: 80
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "A"

  #  81  Discharging OC Protection Delay Time  2 byte  RW   uint8  0.1S 1~255
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Discharging Overcurrent Protection Delay Time"
    use_write_multiple: true
    address: 81
    register_type: holding
    value_type: U_WORD
    lambda: "return  x * 0.1f; "
    write_lambda: "return x * 10.0f;"
    min_value: 0.1
    max_value: 25.5
    step: 0.1
    mode: box
    unit_of_measurement: "s"

  #  82  Discharging OC-2 Protection             2 byte  RW  uint16  A
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Discharging Overcurrent 2 Protection"
    use_write_multiple: true
    address: 82
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "A"

  #  83  Discharging OC-2 Protection Delay Time  2 byte  RW   uint8  0.025S 1~255
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Discharging Overcurrent 2 Protection Delay Time"
    use_write_multiple: true
    address: 83
    register_type: holding
    value_type: U_WORD
    lambda: "return  x * 0.1f; "
    write_lambda: "return x * 10.0f;"
    min_value: 0.1
    max_value: 25.5
    step: 0.1
    mode: box
    unit_of_measurement: "s"

  # #  84  Charging OT Alarm                     2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Charging Overtemperature Alarm"
  #   use_write_multiple: true
  #   address: 84
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  85  Charging OT Protection                2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Charging Overtemperature Protection"
  #   use_write_multiple: true
  #   address: 85
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  86  Charging OT Release Protection        2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Charging Overtemperature Protection Release"
  #   use_write_multiple: true
  #   address: 86
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  87  Discharging OT Alarm                  2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Discharging Overtemperature Alarm"
  #   use_write_multiple: true
  #   address: 87
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  88  Discharging OT Protection             2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Discharging Overtemperature Protection"
  #   use_write_multiple: true
  #   address: 88
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  89  Discharging OT Release                2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Discharging Overtemperature Protection Release"
  #   use_write_multiple: true
  #   address: 89
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  90  Charging UT Alarm                     2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Charging Undertemperature Alarm"
  #   use_write_multiple: true
  #   address: 90
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  91  Charging UT Protection                2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Charging Undertemperature Protection"
  #   use_write_multiple: true
  #   address: 91
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  92  Charging UT Release Protection        2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Charging Undertemperature Protection Release"
  #   use_write_multiple: true
  #   address: 92
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  93  Discharging UT Alarm                  2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Discharging Undertemperature Alarm"
  #   use_write_multiple: true
  #   address: 93
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  94  Discharging UT Protection             2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Discharging Undertemperature Protection"
  #   use_write_multiple: true
  #   address: 94
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  95  Discharging UT Release Protection     2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Discharging Undertemperature Protection Release"
  #   use_write_multiple: true
  #   address: 95
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  96  MOSFET OT Alarm                       2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} MOSFET Overtemperature Alarm"
  #   use_write_multiple: true
  #   address: 96
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  97  MOSFET OT Protection                  2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} MOSFET Overtemperature Protection"
  #   use_write_multiple: true
  #   address: 97
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  98  MOSFET OT Release Protection          2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} MOSFET Overtemperature Protection Release"
  #   use_write_multiple: true
  #   address: 98
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  99  Environment OT Alarm                  2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Environment Overtemperature Alarm"
  #   use_write_multiple: true
  #   address: 99
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # # 100  Environment OT Protection             2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Environment Overtemperature Protection"
  #   use_write_multiple: true
  #   address: 100
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # # 101  Environment OT Release Protection     2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Environment Overtemperature Protection Release"
  #   use_write_multiple: true
  #   address: 101
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # # 102  Environment UT Alarm                  2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Environment Undertemperature Alarm"
  #   use_write_multiple: true
  #   address: 102
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  103  Environment UT Protection             2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Environment Undertemperature Protection"
  #   use_write_multiple: true
  #   address: 103
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  # #  104  Environment UT Release Protection     2 byte  RW   int16  0.1 ℃
  # - platform: modbus_controller
  #   modbus_controller_id: ${modbus_controller_id}
  #   name: "${friendly_name} ${pack} Environment Undertemperature Protection Release"
  #   use_write_multiple: true
  #   address: 104
  #   register_type: holding
  #   value_type: S_WORD
  #   lambda: "return  x * 0.1f; "
  #   write_lambda: "return x * 10.0f;"
  #   min_value: -200.0
  #   max_value: 200.0
  #   step: 0.1
  #   mode: box
  #   unit_of_measurement: "°C"

  #  105  Balance Start Cell Voltage            2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Balance Start Cell Voltage"
    use_write_multiple: true
    address: 105
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  106  Balance Start Delta Voltage           2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Balance Start Delta Voltage"
    use_write_multiple: true
    address: 106
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  107   Full-Charge Voltage              2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} ${pack} Full-Charge Voltage"
    use_write_multiple: true
    address: 107
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  108   Full-Charge Current              2 byte  RW  uint16  mA
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Pack Full-Charge Current"
    use_write_multiple: true
    address: 108
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mA"

  #  109  Cell Sleep Voltage                    2 byte  RW  uint16  mV
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Sleep Voltage"
    use_write_multiple: true
    address: 109
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "mV"

  #  110  Cell Sleep Delay Time                 2 byte  RW  uint16  min
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Cell Sleep Delay Time"
    use_write_multiple: true
    address: 110
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "min"

  #  111  Short Circuit Protect Delay Time      2 byte  RW   uint8  25uS Max 500uS
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Short Circuit Protect Delay Time"
    use_write_multiple: true
    address: 111
    register_type: holding
    value_type: U_WORD
    lambda: "return x * 25.0f; "
    write_lambda: "return x * 0.04f;"
    min_value: 25.0
    max_value: 500.0
    step: 25.0
    mode: box
    unit_of_measurement: "us"

  #  112  SOC Alarm Threshold                   2 byte  RW   uint8  % 0~100%
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} State of Charge Alarm Threshold"
    use_write_multiple: true
    address: 112
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 100.0
    step: 1
    mode: box
    unit_of_measurement: "%"

  #  113  Charging OC-2 Protection              2 byte  RW  uint16  A
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Charging Overcurrent 2 Protection"
    use_write_multiple: true
    address: 113
    register_type: holding
    value_type: U_WORD
    min_value: 0.0
    max_value: 65535.0
    step: 1
    mode: box
    unit_of_measurement: "A"

  #  114  Charging OC-2 Protection Delay Time   2 byte  RW   uint8  0.025S 1~255
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Charging Overcurrent 2 Protection Delay Time"
    use_write_multiple: true
    address: 114
    register_type: holding
    value_type: U_WORD
    lambda: "return x * 25.0f; "
    write_lambda: "return x * 0.04f;"
    min_value: 25.0
    max_value: 6375.0
    step: 25.0
    mode: box
    unit_of_measurement: "ms"
text_sensor:
  #   9  Warning flag                          2 byte   R  uint16  Hex See ^1
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Warnings"
    address: 9
    register_type: holding
    register_count: 1
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      static const uint8_t WARNINGS_SIZE = 16;
      static const char *const WARNINGS[WARNINGS_SIZE] = {
          "Cell overvoltage",              // 0000 0000 0000 0001 (1)
          "Cell undervoltage",             // 0000 0000 0000 0010 (2)
          "Pack overvoltage",              // 0000 0000 0000 0100 (3)
          "Pack undervoltage",             // 0000 0000 0000 1000 (4)
          "Charging overcurrent",          // 0000 0000 0001 0000 (5)
          "Discharging overcurrent",       // 0000 0000 0010 0000 (6)
          "Reserve (Bit 7)",               // 0000 0000 0100 0000 (7)
          "Reserve (Bit 8)",               // 0000 0000 1000 0000 (8)
          "Charging overtemperature",      // 0000 0001 0000 0000 (9)
          "Discharging overtemperature",   // 0000 0010 0000 0000 (10)
          "Charging undertemperature",     // 0000 0100 0000 0000 (11)
          "Discharging undertemperature",  // 0000 1000 0000 0000 (12)
          "Environment overtemperature",   // 0001 0000 0000 0000 (13)
          "Environment undertemperature",  // 0010 0000 0000 0000 (14)
          "MOSFET overtemperature",        // 0100 0000 0000 0000 (15)
          "Low state of charge",           // 1000 0000 0000 0000 (16)
      };
      std::string values = "";

      uint16_t mask = modbus_controller::word_from_hex_str(x, 0);
      if (mask) {
        for (int i = 0; i < WARNINGS_SIZE; i++) {
          if (mask & (1 << i)) {
            values.append(WARNINGS[i]);
            values.append(";");
          }
        }
        if (!values.empty()) {
          values.pop_back();
        }
      }
      return values;

  #  10  Protection flag                       2 byte   R  uint16  Hex See ^2
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Protections"
    address: 10
    register_type: holding
    register_count: 1
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      static const uint8_t PROTECTIONS_SIZE = 16;
      static const char *const PROTECTIONS[PROTECTIONS_SIZE] = {
          "Cell overvoltage",              // 0000 0000 0000 0001 (1)
          "Cell undervoltage",             // 0000 0000 0000 0010 (2)
          "Pack overvoltage",              // 0000 0000 0000 0100 (3)
          "Pack undervoltage",             // 0000 0000 0000 1000 (4)
          "Charging overcurrent",          // 0000 0000 0001 0000 (5)
          "Discharging overcurrent",       // 0000 0000 0010 0000 (6)
          "Short circuit",                 // 0000 0000 0100 0000 (7)
          "Charging overvoltage",          // 0000 0000 1000 0000 (8)
          "Charging overtemperature",      // 0000 0001 0000 0000 (9)
          "Discharging overtemperature",   // 0000 0010 0000 0000 (10)
          "Charging undertemperature",     // 0000 0100 0000 0000 (11)
          "Discharging undertemperature",  // 0000 1000 0000 0000 (12)
          "MOSFET overtemperature",        // 0001 0000 0000 0000 (13)
          "Environment overtemperature",   // 0010 0000 0000 0000 (14)
          "Environment undertemperature",  // 0100 0000 0000 0000 (15)
          "Fully Charged",                 // 1000 0000 0000 0000 (16)
      };
      std::string values = "";

      uint16_t mask = modbus_controller::word_from_hex_str(x, 0);
      if (mask) {
        for (int i = 0; i < PROTECTIONS_SIZE; i++) {
          if (mask & (1 << i)) {
            values.append(PROTECTIONS[i]);
            values.append(";");
          }
        }
        if (!values.empty()) {
          values.pop_back();
        }
      }
      return values;

  #  11  Status/Fault flag                     2 byte   R  uint16  Hex See ^3
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Faults"
    address: 11
    register_type: holding
    register_count: 1
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      static const uint8_t FAULTS_SIZE = 8;
      static const char *const FAULTS[FAULTS_SIZE] = {
          "Charging MOSFET fault",                   // 0000 0000 0000 0001 (1)
          "Discharging MOSFET fault",                // 0000 0000 0000 0010 (2)
          "Temperature sensor",                      // 0000 0000 0000 0100 (3)
          "Reserve (Bit 4)",                         // 0000 0000 0000 1000 (4)
          "Battery cell fault",                      // 0000 0000 0001 0000 (5)
          "Front end sampling communication fault",  // 0000 0000 0010 0000 (6)
          "Reserve (Bit 7)",                         // 0000 0000 0100 0000 (7)
          "Reserve (Bit 8)",                         // 0000 0000 1000 0000 (8)
      };
      std::string values = "";

      uint16_t mask = modbus_controller::word_from_hex_str(x, 0);
      if (mask) {
        for (int i = 0; i < FAULTS_SIZE; i++) {
          if (mask & (1 << i)) {
            values.append(FAULTS[i]);
            values.append(";");
          }
        }
        if (!values.empty()) {
          values.pop_back();
        }
      }
      return values;

  #  11  Status/Fault flag                     2 byte   R  uint16  Hex See ^3
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Status"
    address: 11
    register_type: holding
    register_count: 1
    response_size: 2
    raw_encode: HEXBYTES
    lambda: |-
      static const uint8_t STATUS_SIZE = 8;
      static const char *const STATUS[STATUS_SIZE] = {
          "CHG",
          "DCHG",
          "MOSFET_CHG",
          "MOSFET_DCHG",
          "LIMIT_CHG",
          "Reserve (Bit 13)",
          "Charger inversed",
          "HEAT",
      };
      std::string values = "";

      uint16_t mask = modbus_controller::word_from_hex_str(x, 0);
      if (mask) {
        for (int i = 8; i < (STATUS_SIZE+8); i++) {
          if (mask & (1 << i)) {
            values.append(STATUS[i-8]);
            values.append(";");
          }
        }
        if (!values.empty()) {
          values.pop_back();
        }
      }
      return values;

  # 150  Version information                  20 byte   R  uint16  ASCII
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Version Information"
    skip_updates: 60
    address: 150
    register_type: holding
    register_count: 10
    response_size: 20

  # 160  Model SN                             20 byte  RW  uint16  ASCII BMS Manufacturer
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} BMS Serial Number"
    skip_updates: 60
    address: 160
    register_type: holding
    register_count: 10
    response_size: 20

  # 170  PACK SN                              20 byte  RW  uint16  ASCII PACK Manufacturer
  - platform: modbus_controller
    modbus_controller_id: ${modbus_controller_id}
    name: "${friendly_name} ${pack} Battery Serial Number"
    skip_updates: 60
    address: 170
    register_type: holding
    register_count: 10
    response_size: 20
